# 1. 단순 객체복제

[얕은 복사와 깊은 복사 연산](https://docs.python.org/ko/3/library/copy.html)

```python
a = [1, 2, 3, 4]
b = a
print(b) # [1, 2, 3, 4]
b[2] = 100
print(b) # [1, 2, 100, 4]
print(a) # [1, 2, 100, 4]
```

리스트 [1,2,3,4]를 만들고 해당 객체 주소를 a에 할당한 뒤 `b = a`로 b에 대입해주면 b 또한 a가 쳐다보고 있는 주소와 같은 객체를 쳐다보게됩니다. 때문에 발생되는 것이 `b[2]`를 수정하게되면 `a[2]`도 같이 수정 아니 같은 곳이 수정되기 때문에 a, b를 출력했을 때 같은 결과값이 나오게 됩니다.

이것은 당연히 동일 객체를 참조하고 있기 때문에 발생하는 문제겠지요. 이와 같은 현상은 리스트와 같은 변경가능한 즉 mutable한 객체일 때만 해당하고 숫자 등과 같은 불변 즉 immutable 객체일 때는 해당되지 않습니다. 아래 코드를 보시죠.

```python
a = 10
b = a
print(b) # 10
b = "abc"
print(b) # abc
print(a) # 10
```

이와 같이 불변의 객체의 경우에는 참조변수를 수정한다는 것은 같은 주소의 값이 바뀌는 것이 아니라 해당 변수에 새로운 객체가 할당되게됩니다.

# 2. 얕은 복사(shallow copy)

다음은 얕은 복사의 경우입니다. 단순 복사와의 차이점은 복합객체(리스트)는 별도로 생성하게 되지만, 그 안에 들어가는 내용(data)는 원래와 같은 객체라는 점입니다. 아래 코드를 보시죠.

```python
import copy

a = [1, [1, 2, 3]]
b = copy.copy(a)    # shallow copy 발생
print(b)    # [1, [1, 2, 3]] 출력
b[0] = 100
print(b)    # [100, [1, 2, 3]] 출력,
print(a)    # [1, [1, 2, 3]] 출력, shallow copy 가 발생해 복사된 리스트는 별도의 객체이므로 item을 수정하면 복사본만 수정된다. (immutable 객체의 경우)

c = copy.copy(a)
c[1].append(4)    # 리스트의 두번째 item(내부리스트(mutable객체))에 4를 추가
print(c)    # [1, [1, 2, 3, 4]] 출력
print(a)    # [1, [1, 2, 3, 4]] 출력, a가 c와 똑같이 수정된 이유는 리스트의 item 내부의 객체는 동일한 객체이므로 mutable한 리스트를 수정할때는 둘다 값이 변경됨
```

주석을 보시면 알겠지만, 리스트 내에 리스트가 있는 경우에는 얕은 복사 (`b = copy.copy(a)`)를 해주게 되더라도 리스트 내의 리스트 까지 별도 객체로 복사 되지 않습니다.

먼저 위 코드에서 b의 첫번째 요소를 변경했을때 a가 변경되지 않는 이유는 해당 첫번째 요소는 immutable 하기 때문입니다. immutable 하다는 것은 요소가 수정되는 것이 아니라 그저 다른 값으로 대체된다고 볼 수 있습니다. 그렇기 때문에 b에서 변경된 요소가 a에 반영되지 않는 것 입니다.

하지만 c 의 경우는 좀 다른데, a를 복사해서 (`c = copy.copy(a)`) c를 만들고 이후 c의 두번째 요소(리스트)에 새로운 값을 추가합니다. 이때 출력 결과를 보면 a,b 처럼 각각 수정되기를 기대하지만 그렇지 않은 것을 확인 할 수 있습니다. 그 이유는 a와 c 내부 리스트는 같은 객체를 참조하고 있기 때문입니다. b의 경우도 가장 바깥 리스트의 경우도 같은 객체라고 할 수 있지만, 가장 중요한 차이는 immutable 한 경우에는 값이 수정되는 것이 아니라 아예 새로운 값으로 변경되기 때문인 것이죠. 그래서 위와 같은 결과가 나오게 됩니다.

# 3. 깊은 복사(deep copy)

mutable 한 내부객체(내부 리스트) 문제를 해결하기 위해서는 얕은 복사가 아닌 깊은 복사(deep copy)를 해주어야합니다.

얕은 복사가 복합객체(리스트)만 복사되고 그 안의 내용은 동일한 객체를 참조한다면, 깊은 복사는 복합객체를 새롭게 생성하고 뿐만 아니라 그 안의 내용까지 재귀적으로 새롭게 생성합니다.

그래서 깊은 복사를 하게되면, 처음에 만들었던 객체와 복사된 객체가 전혀 달라지기 때문에 어떤 한쪽을 수정한다고 해서 다른 한쪽이 영향을 받는 일은 없게 되는 것입니다.

파이썬에서는 이를 copy 모듈의 deepcopy()라는 메서드를 통해서 깊은 복사를 쉽게 구현가능합니다.

```python
import copy

a = [1, [1, 2, 3]]
b = copy.deepcopy(a)    # deep copy 실행
print(b)    # [1, [1, 2, 3]] 출력
b[0] = 100
b[1].append(4)
print(b)    # [100, [1, 2, 3, 4]] 출력
print(a)    # [1, [1, 2, 3]] 출력
```

# 4. 결론
0. **단순 복사**
- 완전 동일한 객체
1. **얕은 복사(Shallow copy)**
- 객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다.
- 복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다.
- 따라서, 해당 메모리 주소의 값이 변경되면 원본 객체 및 복사 객체의 인스턴스 변수 값은 같이 변경된다.
- 얕은복사(shallow copy)는 복합객체(껍데기)만 복사, 그 내용은 동일한 객체
- 얕은 복사는 새로운 복합 객체를 만들고,(가능한 범위까지) 원본 객체를 가리키는 참조를 새로운 복합 객체에 삽입합니다.
- A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.
2. **깊은 복사(Deep copy)**
- 객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.
- 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않게 된다.
- 깊은복사(deep copy)는 복합객체 복사 + 그 내용도 재귀적으로 복사
- 깊은 복사는 새로운 복합 객체를 만들고,재귀적으로 원본 객체의 사본을 새로 만든 복합 객체에 삽입합니다.
- A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.
  
**깊은 복사의 문제점**
- 재귀 객체(직접적 또는 간접적으로 자신에 대한 참조를 포함하는 복합 객체)는 순환 루프의 원인이 될 수 있습니다.
- 깊은 복사는 모든 것을 복사하기 때문에, 지나치게 많이 복사할 수 있습니다. 가령, 복사본 간에 공유할 의도가 있는 것까지도.